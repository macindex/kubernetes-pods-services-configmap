Agora nós vamos criar o nosso primeiro pod de maneira declarativa. O que isso quer dizer? Quer dizer que agora nós vamos precisar trabalhar com algum editor de texto. Eu, no caso, vou utilizar o Visual Studio Code para nós podermos fazer todo o nosso processo de criação de arquivos.
Então eu criei uma pasta e vou abrir ela, chamada “kubernetes-alura”, e dentro dela vai ser onde nós vamos fazer todo o nosso processo de criação de arquivos. Então dentro dessa pastinha nós vamos criar os nossos arquivos de definição.
Mas como isso funciona? É bem simples na verdade, basta nós criarmos um novo arquivo dentro dessa pasta e nomear ele. Então eu vou chamar ele de “primeiro-pod” e ele precisa ter uma extensão específica para que o kubectl consiga enviar ele e a API consiga interpretar. Então, ou ele pode ser um .json, ou ele pode ser um .yaml também.
O mais comum e fácil de se trabalhar é o .yaml, então vai ser ele que nós vamos utilizar daqui para o final do curso.
Então dentro desses arquivos nós precisamos começar a escrever e a informar algumas coisas, como por exemplo: qual é a versão da API que nós queremos utilizar.
“Como assim versão da API, Daniel?” Se nós viermos na documentação, nós vamos entender que na verdade a API era uma única aplicação centralizada que foi dividida em diversas partes. Embaixo nós temos uma delas, por exemplo: a versão alfa, a versão beta e a versão estável.
Onde a alfa tem coisas que podem ainda estar contendo bug; embaixo nós temos a beta que já pode ser considerada segura, mas ainda não é bom utilizar definitivamente; e a versão estável que é um “v” seguido de um número inteiro, onde é a versão estável efetivamente para uso.
E ela possui também diversos grupos para nós utilizarmos. Como nós queremos criar um pod, o pod está dentro da versão estável da API, logo está na versão “v” seguida de algum número - nesse caso ele está na versão “v1”.
Logo depois nós precisamos informar o que nós queremos criar. Nós queremos criar um pod, então o tipo do que nós queremos criar, dos recursos que nós queremos criar, é um pod.
Logo depois nós definimos quais são os metadados desse pod. Como, por exemplo: nós vamos definir qual nome nós vamos dar para ele, no caso dentro de metadados nós vamos definir essas informações.
Como nós queremos fazer isso dentro de metadata, eu vou dar usar a tecla “Tab” e vou escrever que o nome que eu quero dar para esse pod vai ser o nosso primeiro-pod-declarativo e fechar. Não tem mais nada para colocar no meu metadado.
E agora, quais são as especificações que eu quero dar para esse pod. Eu quero que ele contenha um container, um ou mais containers. Aqui no caso que tenho o nome de, no caso, nginx-container, que eu posso dar qualquer nome a esse container. É irrelevante para o nosso caso. Logo depois eu posso definir qual imagem eu quero utilizar para esse container.
Então nós queremos utilizar mais uma vez a versão do nginx na versão latest. Repare que eu coloquei um tracinho. Por quê? Eu posso ter diversos desses pares para definir exatamente essa questão, eu posso ter múltiplos containers dentro de um pod. Então esse tracinho é para marcar o início de uma nova declaração dentro do nosso container, mas nós só queremos um container dentro desse pod. Então ele está feito.
E agora, como nós utilizamos esse arquivo de definição? É bem fácil! Basta nós acessarmos essa mesma pasta que eu criei, no caso “kubernetes-alura”. E pedir para o kubectl fazer o quê? Não para ele criar um pod da maneira como nós fizemos antes, mas para ele aplicar o nosso arquivo de definição chamado de primeiro-pod.
E olhe que legal, ele fala que o nosso primeiro-pod agora foi criado. Se nós dermos o comando kubectl get pods - está ele, o nosso primeiro pod declarativo, 1/1 rodando.
E olhe que legal - agora nós só precisamos utilizar o nosso arquivo de definição e o comando foi para entregar esse arquivo para a API fazer e tomar a ação necessária!
Então nós não precisamos mais nos preocupar com qual comando nós vamos utilizar, e sim em entregar um arquivo de definição para o Kubernetes fazer o que nós queremos.
Então nós vamos ficar aplicando esses arquivos de definição, declarativos para criar os nossos recursos. Olhe que legal!
E com isso fica bem mais fácil nós manusearmos os nossos recursos. Por quê? Porque digamos que agora eu quero utilizar de novo a versão 1.0 que não existe do nginx. Basta eu vir no meu arquivo de definição, trocar para a versão 1.0 e aplicar esse arquivo novamente, o mesmo comando, a mesma ideia.
Ele vai nos informar que o pod não foi criado, e sim configurado; porque ele já existe e uma ação foi realizada sobre ele. Se nós formos olhar exatamente a mesma coisa, ele não conseguiu baixar a imagem. Se nós continuarmos repetindo isso, em algum momento ele vai cair nesse ImagePullBackOff.
E agora nós editamos. Conseguimos editar ele de uma maneira bem mais prática em relação àquele arquivo gigante que nós tínhamos, que também era um .yaml, mas era bem mais complexo de se entender.
Agora nós temos um arquivo mais simples, isso significa que se eu voltar e tentar colocar uma outra versão - por exemplo, a stable do nosso nginx, que é uma versão que existe; se eu voltar e aplicar de novo o nosso arquivo de definição, olhe que legal!
Vamos executar o kubectl get pods e vamos observar o que vai acontecer. Ele vai continuar com esse status de erro, mas ainda ele não se configurou, ele ainda não atualizou ali efetivamente. E agora sim ele baixou e está utilizando a nova imagem.
Se nós apertarmos as teclas “Control + C” e descrever esse nosso pod que nós fizemos o nosso primeiro pod declarativo.
A atribuição do scheduler como antes, a criação; o erro do ImagePullBackOff, que ele continuou tentando utilizar da versão 1.0; depois a nova tentativa de baixar a versão estável e a criação. Tudo feito sem nenhum problema, olhe que legal!

E isso tudo só com um comando, então nós centralizamos diversas dessas ações através desse único comando kubectl apply, ou seja, o kubectl foi responsável por fazer a comunicação com a API. Nós aplicamos um arquivo, esse -f de file - na verdade chamado primeiro-pod.yaml - e a mágica foi feita sem nenhum mistério, nós só definimos o que nós queríamos e isso foi criado dentro do nosso cluster.

Então a partir de agora, o que nós estamos conseguindo fazer? Nós estamos conseguindo criar, gerenciar e manipular recursos através de um único comando de uma maneira que é bem mais usada em produção e tendo um registro de como está o nosso estado atual.

Basta nós consultarmos um arquivo e vermos como nós queremos que o nosso recurso esteja, e ele vai estar conforme o arquivo de declaração de definição.


