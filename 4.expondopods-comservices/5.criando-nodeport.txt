Tendo entendido o que são ClusterIP, fica muito mais fácil nós entendermos do que que se trata um NodePort. Eles nada mais são do que um tipo de serviço que permitem a comunicação com o mundo externo.
Então agora nós conseguimos fazer uma requisição, enviar uma requisição de uma na que não está dentro do nosso cluster para o nosso cluster, para algum pod dentro dele.
Então significa que agora nós conseguimos acessar, por exemplo, a partir do navegador alguma aplicação que está dentro do nosso cluster, utilizando o nosso NodePort.
E ele vai além disso, ele também funciona dentro do próprio cluster como um ClusterIP. Então se você quer ter algum pod que além de ser acessado dentro do cluster, também deve ser acessado de maneira externa, você pode utilizar o NodePort, porque ele também vai funcionar como ClusterIP.
Isso significa que, por exemplo, este pod, que tem a label version 2.0, consegue ser acessado tanto por esse pod de dentro do cluster a partir desse serviço, quanto das mnas fora do nosso cluster, também a partir desse serviço.
Então agora nós vamos conseguir fazer toda a criação do nosso NodePort. Nós vamos deixar posteriormente tudo bem elaborado com o projeto. Como eu falei para vocês, nós vamos alcançar o estado onde nós conseguimos gerenciar múltiplos pods com o mesmo serviço, tudo a partir das nossas labels e com o balanceamento de carga automático. Mas vamos com calma, vamos primeiro criar o nosso NodePort na primeira vez.
Qual é a ideia ? Nós já temos o nosso cluster do jeito que ele está agora, nós temos o nosso pod-1, o nosso pod-2, o nosso portal-noticias e um serviço que faz essa requisição esse tratamento de requisição para enviar para o nosso pod-2 - tudo isso feito através das nossas labels que nós criamos.
Ícone de "SVC" com legenda "NodePort" ao lado do texto "Abre comunicação para o mundo externo" sobre um computador com uma seta indicando para a área tracejada de "Cluster". Dentro desta, há o "selector:" de "version: 1.0" sobre o ícone de "SVC" conectado a três pods de "version 1.0", e outro "selector:" de "version: 2.0" com ícone de "SVC" conectado a um pod e a outro pod de "version: 2.0". Ao lado, há o texto "NodePorts também funcionam ClusterIPs"
A ideia agora vai ser bem parecida, só que nós vamos querer criar um serviço para o nosso pod-1, onde ele vai expor o nosso pod-1 para o mundo externo. Então, agora nós precisamos, mais uma vez, voltar ao nosso Visual Studio Code. Nós já temos o nosso pod-1 e o nosso pod-2, o nosso portal-noticias também e o ClusterIP criado anteriormente já rodando.
Área tracejada de Cluster contendo o ícone de "svc-pod-1" vindo de fora deste e ligado ao "pod-1" ligado ao "svc-pod-2", que por sua vez está ligado pela porta ":80" ao "pod-2". O ícone pod de "portal-noticias" se conecta ao "svc-pod-2".
A ideia agora vai ser nós criarmos o nosso servisse chamado NodePort desse tipo. A ideia é bem parecida, vamos chamar então de name: svc-pod-1 porque esse serviço vai ser voltado para o nosso pod-1.
E nós vamos definir a versão da API também como V1. Nada de novo, o tipo ainda é um serviço, um service, então escrevemos Service .
Na metadata vamos dar um nome para ele, vamos seguir a mesma ideia que nós colocamos no anterior que vai sersvc-pod-2. nós vamos colocar também svc-pod-1.
Nas especificações, olhe só como é bem parecido: o tipo, ao invés de ser ClusterIP, vai ser um NodePort. Olhe que legal!
E dentro nós também vamos ter aquelas configurações de porta. Vamos definir, qual é a porta que, como eu falei para vocês, esse serviço, o nosso NodePort também vai funcionar como ClusterIP.
Então, de maneira similar ao nosso serviço 2, nós também vamos definir um port dentro. Qual é a porta em que o nosso serviço vai ouvir dentro do cluster? Nós queremos, por exemplo, que seja na porta 8080. Nós temos total liberdade para isso.
Vamos colocar só port: 80. Lembra que eu falei para vocês que se nós definirmos só a port, implicitamente ele vai nos definir também o TargetPort sendo igual ao port? Então nós não precisamos explicitar o TargetPort se nós explicitarmos só o port, ele assume que os dois são iguais se nós definirmos só o primeiro.
Então, agora nós já definimos o nosso port. Se nós tentarmos executar para valer, ele vai funcionar a princípio. Vamos ver, eu vou salvar, vou no nosso Powershelle vou digitar kubectl apply -f .\svc-pod-1.yaml.
Se nós apertarmos a tecla “Enter”, ele vai ser criado. Mas ainda faltam alguns pequenos detalhes. Como, por exemplo: nós temos o nosso serviço do tipo NodePort, eu vou separar a tela mais uma vez, vou dar um split.
E nós precisamos, assim como nós fizemos anteriormente, fazer o bound desse serviço com este pod? Então, vamos colocar as labels, no caso, vamos seguir a mesma ideia de, por exemplo: app e vamos chamar ele de primeiro-pod para seguirmos o mesmo padrão que nós viemos fazendo.
E nós vamos adicionar fora de port alinhado, o seletor. Então: selector: e vamos chamar o nosso app: primeiro-pod.
Então agora, como isso vai funcionar ? Se nós voltarmos e configurarmos os dois da maneira correta... Configuramos o nosso serviço e agora nós configuramos também o nosso pod. Devidamente configurado!
E se nós tentarmos, como eu falei para vocês, fazer o acesso a partir de dentro do cluster, nós vamos conseguir. Então, vamos lá!
Vamos digitar kubectl get svc. Está o nosso svc-pod-1, ele tem esse IP e olhe só como ele nos mostra que ele faz o bound da porta 80 para a porta 363. O que isso quer dizer? Nós vamos entender, com calma.
Primeiro nós vamos fazer o mesmo teste que nós fizemos com o ClusterIP. Vamos acessar ele a partir do nosso portal de notícias. Então, docker não, kubectl exec –it. Vamos executar o nosso portal-notIcias em modo interativo e o bash.
Se nós colocarmos, fazer um curl novamente para 10.104.108.232, que é o nosso IP na porta 80, o que vai acontecer? Mágica! Tudo continua funcionando sem nenhum problema!
Mas como nós fazemos para acessar agora esse NodePort a partir do mundo externo, a partir do nosso navegador? Então vou abrir uma nova aba. Vamos lá, o que vai acontecer ?
Se nós tentarmos acessar esse serviço... Vamos colocar o IP dele, vamos pegar 10.104.108.232 e vamos colocar ele na porta 80. O que vai acontecer pessoal? Ele está carregando e mais uma vez aparentemente está demorando demais e não vai conseguir.
Por quê? Porque olhe só a peculiaridade. Vou limpar a nossa tela e vou apertar as teclas “Ctrl + D” para sair de dentro do container. Vou digitar get svc de novo, para nós destrancarmos melhor.
Nós temos o nosso IP para esse svc-pod-1, mas repare na coluna que ele está! ClusterIP.
O que isso quer dizer? Quer dizer que esse IP é para comunicação dentro do cluster. Então qual é o IP que eu devo utilizar para fazer a comunicação a partir de fora do cluster? Eu tenho que fazer isso a partir do IP do meu nó, porque é um NodePort.
Então se eu vier e fizer kubectl get nodes -o wide para ele botar o IP, olhe só - o nosso external IP no caso do Windows é none e o nosso IP interno é 192.168.65.3.
No caso do Windows, agora é um momento em que nós vamos ter uma pequena diferença entre o pessoal que está no Windows e no Linux, porque no caso do Docker Desktop no Windows ele faz um bound automaticamente do Docker Desktop para o nosso LocalHost, então o IP desse nó no Windows vai ser LocalHost.
Então se nós viermos no nosso navegador e colocarmos LocalHost na porta 80, nós vamos a princípio acessar, só que não é isso que nós queremos. Isso é o Windows que tem alguma coisa rodando na porta 80 para nós. O que nós queremos acessar é a página do nginx.
Mas eu botei, não botei pessoal!? A porta 80? Por que eu não estou conseguindo acessar? Por que isso não funciona? Porque, na verdade, se nós formos um pouco mais "malandros", nós vamos observar que a porta 80 é a de uso interno do cluster, mas ele faz o bound para a porta 30363 - que é aquela porta louca que nós vimos.
Então se nós copiarmos esse número, pegarmos esse 30363 e colocarmos LocalHost nessa porta – mágica! Nós conseguimos agora a nossa aplicação através do nosso serviço de maneira externa.
Mas tem uma peculiaridade: esse número é arbitrário, ele vai variar de 30000 até 32000 e alguma coisa, é um intervalo, é 32767. Mas nós temos a liberdade para nós definirmos o NodePort que nós queremos utilizar.
Então vamos fazer o seguinte: nós podemos voltar no nosso serviço que nós acabamos de definir e definirmos também uma instrução, um outro campo chamado NodePort, onde nós podemos definir qualquer valor no intervalo de 30000 até 32767.
Nesse caso vou colocar, por exemplo, o próprio 30000, vou apertar as teclas "Ctrl + S". No momento em que eu aplicar a minha mudança a esse serviço, olhe o que vai acontecer.
Ele foi configurado! Se nós digitarmos get svc de novo, olhe só, LocalHost 30000. Então se nós viermos e executarmos na porta 30000, repare que tudo continua funcionando.
Agora pessoal, repare que tudo, da maneira como nós esperávamos e que nós vamos fazer agora. Eu vou dar uma pequena pausa, nós vamos cortar esse vídeo e eu vou entrar no Linux para o pessoal que também está no Linux entender como tudo funciona sem nenhum problema.
Pessoal, agora nós estamos no Linux, com as exatas mesmas configurações, o pod-1, o pod-2, o portal-notícias, os nossos dois serviços que nós criamos. Nada de novo, os mesmos arquivos.
E a diferença para acessarmos é que se nós viermos no nosso navegador e executarmos localhost:30000, ele não vai conseguir acessar - porque como eu falei para vocês, no Linux nós estamos utilizando o Minikube com o Virtual Box e ele não faz o bind automático para o nosso LocalHost.
Para nós conseguirmos acessar, nós vamos executar o comando kubectl get nodes -o wide e ele vai nos retornar, nessas informações todas, o internal IP.
E vai ser ele. no caso, o meu é 192.168.99.106; no caso de vocês provavelmente vai ser diferente. Então eu vou copiar esse IP e agora no meu navegador vou fazer o acesso através dele na porta 30000. Olhe só que legal, tudo funcionando normalmente!
Então LocalHost não vai funcionar, nós vamos usar o nosso internal IP no Linux. Enquanto no Windows, todo o acesso vai ser via LocalHost porque ele vai bind direto. A única diferença vai ser essa, o comportamento do resto todo é exatamente o mesmo.
Então por esse vídeo é só! NodePort, agora nós conhecemos ele e como nós podemos defini-lo e criá-lo. Eu vejo vocês no próximo vídeo, onde nós vamos falar sobre LoadBalancer. Até mais!