Então, por exemplo: se nós temos esse pod de IP 10.0.0.1, nós conseguimos normalmente nos comunicar com outro pod de IP 10.0.0.2 dentro do nosso cluster.
Mas essa comunicação está sendo bem simples, entre dois pods dentro do nosso próprio cluster. Se nós tivéssemos um cenário um pouco mais bem elaborado, onde nós teríamos um pod responsável pelas aplicações de login com esse IP terminado em .1, um de busca com .2, um de pagamentos com .3, um de carrinho com .4 e todos esses pods se comunicariam através dos seus respectivos IPs.
Mas vamos supor que esse pod do carrinho parasse de funcionar, ou seja, ele vai precisar ser substituído. Então criamos um novo pod para o carrinho. Só que nós não temos a garantia de que esse pod vai ter exatamente o mesmo IP do anterior.
Porque se nós viermos no nosso terminal, o que nós conseguiríamos fazer? Nós temos mais uma vez. Deixe-me ver esse para vocês do nosso kubectl get pods. Nós temos o nosso “portal-noticias” que se nós, ao invés de descrevermos ele, utilizarmos esse comando get pod –o para formatarmos o nosso output de maneira “wide”, nós teríamos que o IP dele de 10.1.0.9.
Se nós deletarmos esse nosso pod com o comando kubectl delete –f e passarmos o nosso arquivo de definição para ele - que é o nosso .\portal-notícias.yaml - ou até mesmo, nós deletarmos com o comando kubectl delete pod portal-noticias - que é o nome do nosso pod; ele vai ser removido. Nenhum mistério até aí.
Mas se nós criarmos ele de novo... Vamos executar o comando kubectl apply –f e passar o nosso .\portal-noticias.yaml.
Se nós escrevermos um get pod -o wide de novo, repare, o IP veio diferente. Nós não temos controle sobre isso. Então se nós voltarmos para a nossa apresentação, nós estamos caindo exatamente nesse mesmo problema.
Como esses pods, que se comunicavam com esse pod, vão saber que eles devem se comunicar com esse pod novo? Como eles sabem o IP do pod novo? Essa é a pergunta que nós queremos responder agora.
E para isso nós temos um recurso maravilhoso dentro do Kubernetes, chamado service, ou SVC. Eles são capazes de nos fazer essas coisas. Eles são uma abstração que expõem as aplicações executadas em um ou mais pods e nós permitirmos a comunicação entre diferentes aplicações de diferentes pods e com isso eles provêm IPs fixos.
Então, o IP que nós vamos utilizar para comunicarmos diferentes pods não vai ser o IP do próprio pod, e sim o IP do nosso serviço. Os serviços sempre vão possuir um IP fixo, que nunca vai mudar. Além disso, um DNS que nós podemos utilizar para nos comunicar entre um ou mais pods. Olhe que legal!
E inclusive, eles são capazes também de fazer o balanceamento de carga. Então, como assim? O que isso muda na prática? Se nós voltarmos para aquele exemplo anterior, entre a comunicação do nosso pod de IP terminado em 1 e o terminado em 2, a questão é que nós não vamos nos comunicar com esse pod.2 diretamente.
O nosso pod vai fazer comunicação com o serviço que tem esse DNS ou esse IP que nunca vão mudar, eles são estáveis; então nós temos a garantia que por mais que o IP desse pod mude, ele vai continuar sendo o mesmo, sempre sendo comunicado por causa do nosso serviço.
Então nós precisamos entender que os serviços têm esses três tipos. Entre o ClusterIP, o NodePort e o LoadBalancer, cada um com uma finalidade específica.
E nos próximos vídeos nós vamos entender e aplicar um ClusterIP, um NodePort e um LoadBalancer. Nós vamos entender na prática como utilizamos os serviços para mantermos uma comunicação estável entre todos os nossos pods, entre os nossos recursos dentro do nosso cluster. Então por esse vídeo é só isso! Nós já entendemos qual é o problema e quem vai resolver ele - que são os services. A partir de agora nós vamos implementar, nós vamos criar esses services de maneira também declarativa para resolver os nossos problemas, entendendo cada um desses três tipos: o ClusterIP, o NodePort e o LoadBalancer.
