O primeiro tipo de serviço que nós vamos abordar dentro do Kubernetes é o ClusterIP.
E qual é o propósito dele? Para que ele serve? Ele serve para nada mais, nada menos, que fazer a comunicação entre diferentes pods dentro de um mesmo cluster.
Então, nesse cenário que nós estamos visualizando, todo e qualquer pod. Esse de final .2, .4 e .3 eles vão conseguir fazer a comunicação para este pod de final .1 a partir desse serviço, utilizando o IP e o DNS, ou o DNS no caso desse serviço.
E vale ressaltar que o serviço não é uma via de mão dupla, não é porque este pod tem um serviço que ele vai conseguir se comunicar com os outros que não têm também, porque eles não têm o serviço atrelado a eles. Então unilateralmente falando, todos os outros vão se comunicar a este pod de maneira estável, mas ele só porque é um serviço não vai se comunicar aos outros se eles também não tiverem.
Tendo isso em mente, se nós tentarmos acessar esse pod a partir de fora do cluster, o que vai acontecer? Utilizando esse serviço, claro, ClusterIP, nós não vamos conseguir, porque a comunicação, como eu falei, é apenas interna do cluster utilizando um ClusterIP.
Então vamos começar na prática! Nós vamos criar de início dois pods para fazermos o nosso experimento com o ClusterIP. O que nós vamos fazer imediatamente? Nós vamos primeiro criar um arquivo de definição para esse nosso primeiro pod, o nosso “pod-1.yaml”.
E vamos definir todo ele, a versão da API; nós vamos definir o tipo, que é um pod; no metadata nós vamos definir o nome dele, nós vamos chamar ele de pod-1 assim como o nome do arquivo. Isso não é obrigatório, só frisando.
E nas especificações nós vamos colocar as informações do container que vai compor esse pod, que vai ter um nome também não relevante para nós nesse cenário, mas é sempre bom nós definirmos semanticamente. Vou colocar ele como container-pod-1 e a imagem que ele vai utilizar ainda vai ser do nginx:latest.
Dito isso, nós vamos dar um pequeno parêntese . Caso você esteja olhando para esse arquivo como desenvolvedor, se você não soubesse, olhando na documentação do nginx no Docker Hub, que ele é executado na porta 80 por padrão, como você poderia saber que este container definido dentro desse pod está escutando na porta 80?
A boa prática em questão de documentação seria nós definirmos através desse campo ports e colocarmos dentro a instrução também: containerPort, indicando que este container definido dentro deste pod está ouvindo na porta 80.
Então quando o pod for criado e tiver um IP atribuído a ele, se nós tentarmos fazer essa requisição na porta 80, nós vamos cair no nosso nginx.
Tendo isso já pronto, nós podemos criar o nosso segundo pod. Então a mesma ideia vai ser aplicada. Eu vou copiar e vou criar um novo arquivo chamado “pod-2.yaml”, vou colar e vou trocar para pod-2, para manter o mesmo nome padronizado no container também.
E ele também está exposto na porta 80. Por quê? Não vai dar problema isso? Porque os dois são pods diferentes e cada um tem o seu respectivo IP, então não vai ter nenhum conflito em relação a isso.
Vou salvar os dois arquivos e agora nós vamos criar esses dois pods, com o comando kubectl apply -f .\pod-1.yaml e logo depois também o nosso pod-2.
E agora o que nós temos, se nós voltarmos na nossa apresentação? Nós temos o nosso “Cluster”, o nosso portal de notícias em execução, o nosso “pod-1” e o nosso “pod-2” também.
Só que, falta o que ? Nós termos o nosso serviço. Nesse cenário que nós estamos testando o nosso cluster pela primeira vez a ideia vai ser que esse serviço pod-2 seja voltado apenas ao pod-2.
Então nós queremos criar uma maneira estável de comunicarmos com o nosso segundo pod, então vamos criar esse serviço para nós entendermos como isso funciona.
Assim como nós temos o recurso do pod dentro do Kubernetes, nós temos o recurso de service, de serviço. Como nós queremos criar esse recurso, nada mais válido do que nós criarmos um arquivo de definição. Então vamos criar o nosso “svc-pod-2.yaml”, o nome do arquivo.
E dentro dele nós vamos continuar utilizando a versão 1 da API, nada vai mudar até então. Quando mudar, eu vou destacar isso para vocês e o tipo que nós queremos criar.
É um pod? Não é mais um pod, é um serviço. Olhe que legal! E nós vamos definir no metadata dele o quê? Também um nome, então nós podemos chamar ele de svc-pod-2 e também uma especificação.
E dentro dessa especificação nós também não vamos definir containers, porque ele não é mais um pod. Nós vamos definir o tipo. Qual é o tipo do serviço que nós estamos criando? É um ClusterIP.
E agora, o que nós temos? Se nós salvássemos isso agora, tecnicamente, na teoria nós já temos o nosso serviço. Só que, o que acontece? Quando o nosso pod-1 ou o nosso portal de notícias quiserem se comunicar com o nosso pod-2, ele precisa encaminhar essas requisições que ele receber para o nosso pod-2.
Só que, como ele sabe que ele deve se comunicar com o pod-2? Eu vou dividir a nossa tela, vou dar um Split Right (“View > Editor Layout > Split Right”). Como ele sabe que, isso se refere a isso ?
Caso você esteja pensando, não é pelo nome, o nome é completamente irrelevante nesse caso. Nós precisamos ter uma maneira sólida e estável de fazermos essa atribuição. Esse serviço está selecionando este recurso, e para isso nós temos as labels - lembra que eu falei delas para vocês? Nós vamos usar elas agora!
Então nós podemos e devemos, nesse cenário, etiquetar o nosso recurso - por exemplo: o nosso pod-2 - e informarmos que este serviço seleciona apenas os recursos que possui essa label.
E como isso funciona no nosso arquivo declarativo? Basta nós virmos e definirmos dentro do nosso metadata as labels que nós queremos utilizar, através de uma chave. Nesse caso, app, que nós estamos chamando e um valor que nós definimos como segundo-pod.
E nós também temos a liberdade de utilizarmos quantas e quaisquer label nós quisermos, então qualquer chave com qualquer valor nós podemos definir sem nenhum problema. Nós podemos colocar diversas coisas.
Mas nesse caso o importante é mantermos sempre a semântica, a informação do que realmente está sendo feito.
E agora com a nossa label criada (app), a nossa chave com este valor segundo pod, nós precisamos informar para este serviço que ele vai selecionar todos os recursos que tiverem esta chave app com o valor segundo pod. Olhe que legal!
Então a partir desse momento ele já sabe que quando ele estiver recebendo alguma requisição, ele deve encaminhar para o nosso segundo pod, o nosso pod-2.
Só que outra pergunta: agora, como ele sabe que ele deve despachar a requisição que ele receber para a porta 80 do nosso pod? Porque como nós vimos, o que está sendo exposto dentro desse pod é a porta 80, mas não tem nada claro para esse nosso serviço que ele deve, assim que receber uma requisição, encaminhar ela para a porta 80.
É claro então que nós precisamos definir também configurações de porta dentro - e isso é bem fácil: basta nós definirmos do nosso port, definirmos a instrução port e informarmos qual é a porta que nós queremos ouvir e qual é a porta que nós queremos despachar.
Isso significa o quê? Que nós já sabemos em qual porta nós estamos soltando a nossa requisição. Mas em que porta o nosso serviço está ouvindo? Porque ele vai ter um IP, mas ele vai ter também uma porta para receber essas requisições. Então nós precisamos, e devemos, nesse cenário também definirmos uma porta onde esse serviço vai escutar.
Mas olhe que legal: se nós definirmos a nossa porta - e nós temos a liberdade de definirmos a porta de entrada igual a porta de saída – então, o que nós estamos fazendo? Nós estamos falando que o nosso serviço vai receber as requisições na porta 80 e vai despachar para a porta 80 também. De quem? De qualquer recurso que tiver a label app segundo pod.
Vamos entender isso na prática. Agora nós vamos criar esse recurso efetivamente, vamos atualizar primeiro o nosso pod-2, porque nós definimos essa label para ele, ou seja, agora ele foi configurado.
Se nós viermos em kubectl describe pod pod-2, olhe só, em cima - ele tem as nossas labels, : labels: app-segundo-pod. Que legal!
E se nós agora criarmos o nosso serviço também com kubectl apply -f .\svc-pod-2.yaml - ele foi criado.
Assim como nós temos o comando kubectl get pods, nós temos o comando kubectl get service ou get svc, os dois funcionam.
E ele vai nos mostrar esse nosso serviço. Esse primeiro kubernetes já vem por padrão criado com o nosso cluster. Esse svc-pod-2 é do tipo ClusterIP, ele tem um IP que foi definido ali no momento da criação dele, ele não tem nenhum IP externo e a porta que ele ouve é a porta 80 e vai ser a porta também que ele vai despachar.
Então, como isso vai funcionar agora? Como nós nos comunicamos com o nosso pod-2? Vamos fazer o seguinte: eu vou digitar um kubectl get pods, nós temos o nosso pod-1 e o nosso portal de notícias. Vamos fazer o seguinte: eu vou digitar um kubectl exec -it pod-1 e vou entrar nele com um bash.
O que eu quero fazer agora é enviar uma requisição. Vou fazer um curl para nós pegarmos essa página que nós queremos adquirir. Para onde? Para que o nosso endereço IP do nosso ClusterIP, que é 10.106.130.115. Onde? Na porta 80.
E olhe só que legal: está o nosso retorno do nginx. Se nós tentarmos fazer a mesmíssima coisa a partir do nosso portal de notícias, o que vai acontecer? Vamos lá: curl 10.106.130.115:80. A mesma coisa, que legal! Passei até batido, que legal!
E agora o ponto é o seguinte: eu vou sair de dentro também do nosso pod, do nosso container, vou limpar a nossa tela e vou fazer o seguinte. Eu vou digitar kubectl delete –f e vou deletar o nosso pod-2.
Mas o serviço vai continuar em execução no nosso cluster IP. Não é à toa que se eu executar agora um kubectl get svc, ele vai continuar ouvindo na porta 80.
Se eu tentar mais uma vez executar esse curl que eu acabei de fazer para a porta 80 deste serviço, ele vai continuar ouvindo, mas ele não vai ter lugar nenhum para despachar porque não tem ninguém ouvindo na porta 80. Olhe que triste!
Então, isso significa que se em algum momento nós criarmos qualquer outro pod. Por exemplo: o nosso pod-2 de novo com essa label que ele vai ser selecionado pelo serviço, independentemente do IP dele ser diferente, que nós vimos que vai ser, o comando vai continuar funcionando; porque agora o nosso serviço tem um IP estável, DNS estável para fazer essa comunicação.
Se nós tentarmos, inclusive, também fazer a comunicação via DNS, também vai funcionar. Então, um último comentário também para ficar bem direto e bem passado o que eu quero passar para vocês é que dentro da configuração de porta nós temos a liberdade de definirmos que a porta em que nós vamos ouvir é diferente da porta que nós queremos despachar.
Como assim? nós vamos continuar despachando na porta 80, mas ao invés do nosso serviço ouvir na porta 80, ele pode ouvir em qualquer outra porta. Então basta nós definirmos, por exemplo, a porta 9000. Nós temos essa liberdade.
E ao invés do nosso pod ouvir na porta 9000, nós sabemos que ele está ouvindo na porta 80. Então como a porta que o nosso serviço ouve é diferente da porta que nós queremos ouvir no nosso pod, nós devemos definir também então um outro campo chamado TargetPort - que nesse caso é o 80. Qual é a porta que nós queremos despachar o nosso serviço? A porta 80.
Então se nós salvarmos e executarmos, nós vamos configurar o nosso serviço novamente. Olhe o que que vai acontecer, vamos lá! Ele foi devidamente configurado. Se nós escrevemos kubectl get svc, repare que agora ele não ouve mais na porta 80, ele ouve na porta 9000.
Mas o IP é exatamente o mesmo, a diferença é que agora quando nós fizermos alguma requisição, por exemplo, a partir do nosso portal de notícias para esse pod-2, nós não vamos mais enviar requisição para a porta 80; nós vamos enviar ela para a porta 9000 e tudo vai continuar funcionando.
Então, o que acontece ? Quando nós temos o nosso pods - eu vou botar o - wide para nós vermos o nosso IP - o nosso pod-2 tem este IP que ouve na porta 80, que é onde está a nossa aplicação do nginx.
Vou até abrir mais um texto para nós entendermos. Nós temos o nosso pod no IP 10.1.0.67 ouvindo na porta 80, nós conseguimos nos comunicar a esta aplicação usando este endereço. Mas qual é o problema dela? O problema é que ela não é estável.
Então nós temos total liberdade para fazermos isso, só que se nós tentarmos também nos comunicar agora a partir do IP do nosso serviço, que é 10.106.130.115, o que vai acontecer? Nós precisamos fazer essa comunicação a partir da porta como nós definimos agora, 9000 e ele vai fazer o bound, ele vai fazer esse bind para nós, para o nosso 10.1.0.67 na porta 80.
Então nós também temos a possiblidade de variarmos essa porta, como nós fizemos e da maneira como nós quisermos, contanto que ele esteja livre para este IP e ele vá fazer esse redirecionamento para a nossa TargetPort definida do nosso container, dentro do nosso pod.
Então por esse vídeo é isso! É um primeiro impacto com serviços, então caso vocês tenham alguma dúvida, não hesitem em perguntar. Revejam o vídeo, se ficou alguma coisa pendente, porque tudo isso é muito importante. Nós nos veremos no próximo vídeo, onde nós vamos começar a falar sobre NodePorts. Vejo vocês lá, até mais!
